<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>IA √âchecs - Optimis√© Android</title>
    <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: #1a252f;
            color: #ecf0f1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            margin: 0;
            touch-action: manipulation;
        }
        #game-container {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            max-width: 1400px;
        }
        #board {
            width: 100%;
            max-width: 400px;
            border: 4px solid #34495e;
            border-radius: 5px;
            margin: 0 auto;
        }
        .panel {
            background: #2c3e50;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
            width: 100%;
            max-width: 400px;
        }
        @media (max-width: 768px) {
            #board {
                max-width: 100%;
            }
            .square-55d63 {
                width: 12.5%;
                height: 12.5%;
                padding: 0;
            }
            #game-container {
                flex-direction: column;
            }
        }
        .mobile-help {
            display: block;
            background: #3498db;
            padding: 8px;
            border-radius: 4px;
            margin-bottom: 10px;
            text-align: center;
            font-weight: bold;
        }
        .highlight-move {
            box-shadow: inset 0 0 3px 3px rgba(255, 255, 0, 0.7);
            background-color: rgba(255, 255, 0, 0.3);
        }
        .highlight-selected {
            box-shadow: inset 0 0 3px 3px rgba(255, 165, 0, 0.7);
            background-color: rgba(255, 165, 0, 0.3);
        }
        #tree-container {
            width: 100%;
            max-width: 450px;
            height: 500px;
            overflow-y: auto;
            background: #1a1a1a;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            padding: 10px;
            border: 1px solid #3498db;
        }
        .tree-node {
            margin-left: 20px;
            border-left: 1px solid #444;
            padding-left: 10px;
            margin-top: 5px;
        }
        .node-best { color: #2ecc71; font-weight: bold; }
        .node-good { color: #3498db; }
        .node-bad { color: #e74c3c; }
        .node-score { color: #f1c40f; }
        .node-depth { color: #95a5a6; font-size: 10px; }
        .status-box {
            margin-bottom: 10px;
            padding: 8px;
            background: #1a252f;
            border-left: 4px solid #27ae60;
            font-size: 0.9em;
        }
        button {
            width: 100%;
            padding: 8px;
            background: #27ae60;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .danger {
            background: #e74c3c;
        }
        .weight-viz {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 1px;
            margin-top: 10px;
            background: #111;
        }
        .weight-cell {
            aspect-ratio: 1;
            font-size: 0.6em;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .depth-control {
            display: flex;
            gap: 5px;
            margin: 10px 0;
        }
        .depth-btn {
            width: auto !important;
            padding: 5px 10px !important;
            font-size: 12px;
        }
        .depth-btn.active {
            background: #3498db;
        }
        .thinking {
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body>

    <h1>üß† IA √âchecs - Optimis√© Mobile</h1>

    <div class="mobile-help">
        üì± Sur mobile : touchez une pi√®ce pour voir ses d√©placements possibles, puis touchez une case cible pour la d√©placer.
    </div>

    <div id="game-container">
        <div id="board"></div>

        <div class="panel">
            <div class="status-box"><strong>Tour:</strong> <span id="status">Pr√™t</span></div>
            <div class="status-box">
                <strong>Statistiques:</strong><br>
                Matchs: <span id="game-count">0</span><br>
                Victoires IA: <span id="win-count">0</span><br>
                D√©faites IA: <span id="loss-count">0</span><br>
                Taux: <span id="win-rate">0%</span>
            </div>
            <div class="status-box">
                <strong>Profondeur de recherche:</strong>
                <div class="depth-control">
                    <button class="depth-btn" onclick="setDepth(2)">2 (Rapide)</button>
                    <button class="depth-btn active" onclick="setDepth(3)">3 (Normal)</button>
                    <button class="depth-btn" onclick="setDepth(4)">4 (Lent)</button>
                </div>
                <small>Profondeur actuelle: <span id="current-depth">3</span></small>
            </div>

            <button onclick="resetGame()">üîÑ Nouvelle Partie</button>
            <button class="danger" onclick="resetBrain()">üóëÔ∏è Reset M√©moire</button>

            <hr style="border-color: #34495e;">
            <strong>Carte d'apprentissage :</strong>
            <div id="piece-selector" style="display:flex; gap:2px; margin:5px 0; flex-wrap: wrap;"></div>
            <div class="weight-viz" id="weight-viz"></div>
        </div>

        <div class="panel">
            <strong>üå≤ Arbre d'Analyse (Top Coups √âvalu√©s)</strong>
            <div id="tree-container">
                <div style="color: #95a5a6;">En attente du prochain coup de l'IA...</div>
            </div>
        </div>
    </div>

    <script>
        var board = null;
        var game = new Chess();
        const PIECE_TYPES = ['p', 'n', 'b', 'r', 'q', 'k'];
        const PIECE_SYMBOLS = { p: '‚ôü', n: '‚ôû', b: '‚ôù', r: '‚ôú', q: '‚ôõ', k: '‚ôö' };
        let selectedPiece = 'p';
        let searchDepth = 3;
        let selectedSquare = null;

        let aiMemory = JSON.parse(localStorage.getItem('chessAI_memory_v2')) || {
            gamesPlayed: 0,
            wins: 0,
            losses: 0,
            draws: 0,
            weights: {}
        };

        if (Object.keys(aiMemory.weights).length === 0) {
            PIECE_TYPES.forEach(t => aiMemory.weights[t] = new Array(64).fill(0));
            [27, 28, 35, 36].forEach(idx => aiMemory.weights['p'][idx] = 15);
        }

        const pieceSquareTables = {
            p: [0, 0, 0, 0, 0, 0, 0, 0, 50, 50, 50, 50, 50, 50, 50, 50, 10, 10, 20, 30, 30, 20, 10, 10, 5, 5, 10, 25, 25, 10, 5, 5, 0, 0, 0, 20, 20, 0, 0, 0, 5, -5, -10, 0, 0, -10, -5, 5, 5, 10, 10, -20, -20, 10, 10, 5, 0, 0, 0, 0, 0, 0, 0, 0],
            n: [-50, -40, -30, -30, -30, -30, -40, -50, -40, -20, 0, 0, 0, 0, -20, -40, -30, 0, 10, 15, 15, 10, 0, -30, -30, 5, 15, 20, 20, 15, 5, -30, -30, 0, 15, 20, 20, 15, 0, -30, -30, 5, 10, 15, 15, 10, 5, -30, -40, -20, 0, 5, 5, 0, -20, -40, -50, -40, -30, -30, -30, -30, -40, -50],
            b: [-20, -10, -10, -10, -10, -10, -10, -20, -10, 0, 0, 0, 0, 0, 0, -10, -10, 0, 5, 10, 10, 5, 0, -10, -10, 5, 5, 10, 10, 5, 5, -10, -10, 0, 10, 10, 10, 10, 0, -10, -10, 5, 0, 0, 0, 0, 5, -10, -20, -10, -10, -10, -10, -10, -10, -20],
            r: [0, 0, 0, 0, 0, 0, 0, 0, 5, 10, 10, 10, 10, 10, 10, 5, -5, 0, 0, 0, 0, 0, 0, -5, -5, 0, 0, 0, 0, 0, 0, -5, -5, 0, 0, 0, 0, 0, 0, -5, -5, 0, 0, 0, 0, 0, 0, -5, 0, 0, 0, 5, 5, 0, 0, 0],
            q: [-20, -10, -10, -5, -5, -10, -10, -20, -10, 0, 0, 0, 0, 0, 0, -10, -10, 0, 5, 5, 5, 5, 0, -10, -5, 0, 5, 5, 5, 5, 0, -5, 0, 0, 5, 5, 5, 5, 0, -5, -10, 5, 5, 5, 5, 5, 0, -10, -10, 0, 5, 0, 0, 0, 0, -10, -20, -10, -10, -5, -5, -10, -10, -20],
            k: [-30, -40, -40, -50, -50, -40, -40, -30, -30, -40, -40, -50, -50, -40, -40, -30, -30, -40, -40, -50, -50, -40, -40, -30, -30, -40, -40, -50, -50, -40, -40, -30, -20, -30, -30, -40, -40, -30, -30, -20, -10, -20, -20, -20, -20, -20, -20, -10, 20, 20, 0, 0, 0, 0, 20, 20, 20, 30, 10, 0, 0, 10, 30, 20]
        };

        function customPieceTheme(piece) {
            return `https://assets-themes.chess.com/image/ejgfv/150/${piece.toLowerCase()}.png`;
        }

        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        function setDepth(depth) {
            searchDepth = depth;
            document.getElementById('current-depth').textContent = depth;
            document.querySelectorAll('.depth-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }

        function evaluateBoard(g) {
            if (g.in_checkmate()) return g.turn() === 'b' ? -50000 : 50000;
            if (g.in_draw() || g.in_stalemate() || g.in_threefold_repetition()) return 0;
            let total = 0;
            const values = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 };
            g.board().forEach((row, i) => {
                row.forEach((p, j) => {
                    if (p) {
                        const idx = i * 8 + j;
                        let pieceValue = values[p.type];
                        let posBonus = pieceSquareTables[p.type][idx];
                        let learnedWeight = aiMemory.weights[p.type][idx] || 0;
                        let totalValue = pieceValue + (posBonus * 0.7) + (learnedWeight * 0.3);
                        total += (p.color === 'b' ? totalValue : -totalValue);
                    }
                });
            });
            const currentTurn = g.turn();
            const mobility = g.moves().length;
            total += currentTurn === 'b' ? mobility * 5 : -mobility * 5;
            return total;
        }

        function orderMoves(g, moves) {
            return moves.map(m => {
                let score = 0;
                const move = g.move(m);
                if (move.captured) {
                    const values = { p: 100, n: 320, b: 330, r: 500, q: 900 };
                    score += (values[move.captured] || 0) * 10;
                }
                if (g.in_check()) score += 50;
                if (move.promotion) score += 900;
                g.undo();
                return { move: m, priority: score };
            })
            .sort((a, b) => b.priority - a.priority)
            .map(item => item.move);
        }

        let nodesEvaluated = 0;

        function minimax(g, depth, alpha, beta, isMax, treeElement, isRoot = false) {
            nodesEvaluated++;
            if (depth === 0 || g.game_over()) return evaluateBoard(g);
            let moves = g.moves();
            moves = orderMoves(g, moves);
            const displayLimit = isRoot ? 10 : (depth >= 2 ? 5 : 3);
            let bestEval = isMax ? -Infinity : Infinity;
            for (let i = 0; i < moves.length; i++) {
                const m = moves[i];
                let node = null;
                if (i < displayLimit && treeElement) {
                    const indent = '  '.repeat(4 - depth);
                    node = $('<div class="tree-node"></div>').html(`${indent}${depth === searchDepth ? 'üî∏' : '‚îî‚îÄ'} ${m} <span class="node-depth">[D${depth}]</span>`);
                    treeElement.append(node);
                }
                g.move(m);
                let eval = minimax(g, depth - 1, alpha, beta, !isMax, node, false);
                g.undo();
                if (node) {
                    const scoreClass = eval > 500 ? 'node-best' : eval < -500 ? 'node-bad' : 'node-good';
                    node.append(` <span class="${scoreClass}">[${eval.toFixed(0)}]</span>`);
                }
                if (isMax) {
                    bestEval = Math.max(bestEval, eval);
                    alpha = Math.max(alpha, eval);
                } else {
                    bestEval = Math.min(bestEval, eval);
                    beta = Math.min(beta, eval);
                }
                if (beta <= alpha) {
                    if (treeElement && i < displayLimit) {
                        treeElement.append($('<div class="tree-node" style="color:#e74c3c;">').text('  ‚úÇÔ∏è √âlagage'));
                    }
                    break;
                }
            }
            return bestEval;
        }

        function makeBestMove() {
            let moves = game.moves();
            if (game.game_over()) return handleGameOver();
            const $tree = $('#tree-container').empty();
            const $status = $('#status');
            $status.html('<span class="thinking">‚è≥ IA analyse...</span>');
            $tree.append(`<div><strong>üîç Analyse Profondeur ${searchDepth}</strong></div><hr style="border-color:#444;">`);
            setTimeout(() => {
                nodesEvaluated = 0;
                const startTime = Date.now();
                let moveEvaluations = [];
                moves = orderMoves(game, moves);
                for (let m of moves) {
                    let moveNode = $('<div style="margin: 10px 0; padding: 8px; background: #2c3e50; border-left: 3px solid #3498db;"></div>').html(`<strong style="color:#2ecc71;">Coup: ${m}</strong>`);
                    game.move(m);
                    let val = minimax(game, searchDepth - 1, -Infinity, Infinity, false, moveNode);
                    game.undo();
                    moveEvaluations.push({ move: m, val: val, element: moveNode });
                }
                moveEvaluations.sort((a, b) => b.val - a.val);
                $tree.append('<div style="margin: 10px 0;"><strong>Top Coups √âvalu√©s:</strong></div>');
                moveEvaluations.slice(0, 8).forEach((e, idx) => {
                    e.element.prepend(`<span style="color:#f1c40f;">#${idx + 1}</span> `);
                    $tree.append(e.element);
                });
                const timeElapsed = Date.now() - startTime;
                $tree.append(`<hr style="border-color:#444;"><div style="color:#95a5a6; font-size:11px;">‚ö° ${nodesEvaluated} positions √©valu√©es en ${timeElapsed}ms<br>üéØ Meilleur score: ${moveEvaluations[0].val.toFixed(0)}</div>`);
                let chosenMove = moveEvaluations[0].move;
                game.move(chosenMove);
                board.position(game.fen());
                updateStatus();
                if (game.game_over()) handleGameOver();
            }, 100);
        }

        function handleGameOver() {
            let result = 0;
            let message = "";
            if (game.in_checkmate()) {
                result = game.turn() === 'w' ? 1 : -1;
                message = result === 1 ? "üéâ L'IA gagne par √©chec et mat !" : "üëè Vous avez gagn√© par √©chec et mat !";
                result === 1 ? aiMemory.wins++ : aiMemory.losses++;
            } else if (game.in_draw() || game.in_stalemate()) {
                result = 0;
                message = "ü§ù Match nul";
                aiMemory.draws++;
            }
            const learningRate = result === 1 ? 20 : result === -1 ? -25 : 0;
            game.board().forEach((row, i) => {
                row.forEach((p, j) => {
                    if (p && p.color === 'b') {
                        const idx = i * 8 + j;
                        aiMemory.weights[p.type][idx] += learningRate;
                        aiMemory.weights[p.type][idx] = Math.max(-500, Math.min(500, aiMemory.weights[p.type][idx]));
                    }
                });
            });
            aiMemory.gamesPlayed++;
            localStorage.setItem('chessAI_memory_v2', JSON.stringify(aiMemory));
            updateStatsUI();
            updateWeightVisualization();
            alert(message);
        }

        function updateStatus() {
            const turn = game.turn() === 'w' ? "ü§µ Votre tour (Blanc)" : "ü§ñ Tour de l'IA (Noir)";
            $('#status').html(turn);
            if (game.in_check()) $('#status').append(' <span style="color:#e74c3c;">‚ôî √âCHEC!</span>');
        }

        function updateStatsUI() {
            $('#game-count').text(aiMemory.gamesPlayed);
            $('#win-count').text(aiMemory.wins);
            $('#loss-count').text(aiMemory.losses);
            const winRate = aiMemory.gamesPlayed > 0 ? ((aiMemory.wins / aiMemory.gamesPlayed) * 100).toFixed(1) : 0;
            $('#win-rate').text(winRate + '%');
        }

        function updateWeightVisualization() {
            const weights = aiMemory.weights[selectedPiece];
            const maxW = Math.max(...weights.map(Math.abs), 1);
            let html = '';
            weights.forEach(w => {
                let intensity = Math.min(255, Math.abs(w / maxW * 255));
                let color = w >= 0 ? `rgb(46, ${255-intensity}, 71)` : `rgb(${255-intensity}, 52, 60)`;
                const val = Math.abs(w) > 5 ? Math.round(w) : '';
                html += `<div class="weight-cell" style="background:${color}; color:white; font-weight:bold;">${val}</div>`;
            });
            $('#weight-viz').html(html);
        }

        function initPieceSelector() {
            let html = '';
            PIECE_TYPES.forEach(t => {
                const active = t === selectedPiece ? 'active' : '';
                html += `<button class="depth-btn ${active}" style="width:auto; font-size:14px;" onclick="selectedPiece='${t}';initPieceSelector();updateWeightVisualization();">${PIECE_SYMBOLS[t]} ${t.toUpperCase()}</button>`;
            });
            $('#piece-selector').html(html);
        }

        function resetGame() {
            game.reset();
            board.start();
            updateStatus();
            $('#tree-container').html('<div style="color: #95a5a6;">En attente du prochain coup de l\'IA...</div>');
            removeHighlight();
        }

        function resetBrain() {
            if (confirm('Voulez-vous vraiment effacer toute la m√©moire de l\'IA ?')) {
                localStorage.removeItem('chessAI_memory_v2');
                location.reload();
            }
        }

        function removeHighlight() {
            $('.square-55d63').removeClass('highlight-move highlight-selected');
        }

        function highlightPossibleMoves(square) {
            removeHighlight();
            const moves = game.moves({ square: square, verbose: true });
            moves.forEach(move => {
                $(`.square-${move.to}`).addClass('highlight-move');
            });
            $(`.square-${square}`).addClass('highlight-selected');
        }

        // Gestion des clics pour Android
        function onSquareClick(square) {
            if (game.game_over()) return;
            const piece = game.get(square);
            if (selectedSquare === null) {
                if (piece && piece.color === 'w') {
                    selectedSquare = square;
                    highlightPossibleMoves(square);
                }
            } else {
                const move = game.move({ from: selectedSquare, to: square, promotion: 'q' });
                if (move === null) {
                    if (piece && piece.color === 'w') {
                        selectedSquare = square;
                        highlightPossibleMoves(square);
                    } else {
                        removeHighlight();
                        selectedSquare = null;
                    }
                    return;
                }
                removeHighlight();
                selectedSquare = null;
                updateStatus();
                setTimeout(makeBestMove, 250);
            }
        }

        board = Chessboard('board', {
            draggable: false, // D√©sactive le drag-and-drop partout
            position: 'start',
            pieceTheme: customPieceTheme,
            onClick: onSquareClick
        });

        initPieceSelector();
        updateWeightVisualization();
        updateStatsUI();
        updateStatus();
    </script>
</body>
</html>
