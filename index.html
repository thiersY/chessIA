<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>IA √âchecs V2 - Coups Possibles</title>
    <link rel="stylesheet" href="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.css">
    <script src="https://code.jquery.com/jquery-3.5.1.min.js"></script>
    <script src="https://unpkg.com/@chrisoakman/chessboardjs@1.0.0/dist/chessboard-1.0.0.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chess.js/0.10.3/chess.min.js"></script>

    <style>
        body {
            font-family: 'Segoe UI', sans-serif;
            background-color: #1a252f;
            color: #ecf0f1;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 10px;
            margin: 0;
        }
        #game-container {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
            justify-content: center;
            width: 100%;
            max-width: 1400px;
        }

        #board {
            width: 400px;
            border: 4px solid #34495e;
            border-radius: 5px;
        }

        .panel {
            background: #2c3e50;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.5);
        }

        /* Adaptation mobile */
        @media (max-width: 768px) {
            #board {
                width: 100%;
                max-width: 350px;
            }
            .square-55d63 {
                width: 12.5%;
                height: 12.5%;
                padding: 0;
            }
            .panel {
                width: 100% !important;
                max-width: 400px;
            }
            #game-container {
                flex-direction: column;
                align-items: center;
            }
            .status-box {
                font-size: 14px;
            }
            .mobile-help {
                display: block;
                background: #3498db;
                padding: 8px;
                border-radius: 4px;
                margin-bottom: 10px;
                text-align: center;
                font-weight: bold;
            }
        }

        .mobile-help {
            display: none;
        }

        /* Style de l'arbre */
        #tree-container {
            width: 100%;
            max-width: 450px;
            height: 500px;
            overflow-y: auto;
            background: #1a1a1a;
            border-radius: 8px;
            font-family: monospace;
            font-size: 12px;
            padding: 10px;
            border: 1px solid #3498db;
        }
        .tree-node {
            margin-left: 20px;
            border-left: 1px solid #444;
            padding-left: 10px;
            margin-top: 5px;
        }
        .node-best { color: #2ecc71; font-weight: bold; }
        .node-good { color: #3498db; }
        .node-bad { color: #e74c3c; }
        .node-score { color: #f1c40f; }
        .node-depth { color: #95a5a6; font-size: 10px; }

        .status-box {
            margin-bottom: 10px;
            padding: 8px;
            background: #1a252f;
            border-left: 4px solid #27ae60;
            font-size: 0.9em;
        }
        button {
            width: 100%;
            padding: 8px;
            background: #27ae60;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            margin-bottom: 5px;
            font-weight: bold;
        }
        .danger {
            background: #e74c3c;
        }

        .weight-viz {
            display: grid;
            grid-template-columns: repeat(8, 1fr);
            gap: 1px;
            margin-top: 10px;
            background: #111;
        }
        .weight-cell {
            aspect-ratio: 1;
            font-size: 0.6em;
            display: flex;
            align-items: center;
            justify-content: center;
        }

        .depth-control {
            display: flex;
            gap: 5px;
            margin: 10px 0;
        }
        .depth-btn {
            width: auto !important;
            padding: 5px 10px !important;
            font-size: 12px;
        }
        .depth-btn.active {
            background: #3498db;
        }

        .thinking {
            animation: pulse 1s infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Surbrillance des coups possibles */
        .highlight-move {
            box-shadow: inset 0 0 3px 3px rgba(255, 255, 0, 0.7);
            background-color: rgba(255, 255, 0, 0.3);
        }
        .highlight-selected {
            box-shadow: inset 0 0 3px 3px rgba(255, 165, 0, 0.7);
            background-color: rgba(255, 165, 0, 0.3);
        }
    </style>
</head>
<body>

    <h1>üß† IA √âchecs √âvolutive - Coups Possibles</h1>

    <div class="mobile-help" id="mobile-help">
        üì± Sur mobile : cliquez sur une pi√®ce pour voir ses d√©placements possibles, puis cliquez sur une case cible.
    </div>

    <div id="game-container">
        <div id="board"></div>

        <div class="panel" style="width: 280px;">
            <div class="status-box"><strong>Tour:</strong> <span id="status">Pr√™t</span></div>
            <div class="status-box">
                <strong>Statistiques:</strong><br>
                Matchs: <span id="game-count">0</span><br>
                Victoires IA: <span id="win-count">0</span><br>
                D√©faites IA: <span id="loss-count">0</span><br>
                Taux: <span id="win-rate">0%</span>
            </div>
            <div class="status-box">
                <strong>Profondeur de recherche:</strong>
                <div class="depth-control">
                    <button class="depth-btn" onclick="setDepth(2)">2 (Rapide)</button>
                    <button class="depth-btn active" onclick="setDepth(3)">3 (Normal)</button>
                    <button class="depth-btn" onclick="setDepth(4)">4 (Lent)</button>
                </div>
                <small>Profondeur actuelle: <span id="current-depth">3</span></small>
            </div>

            <button onclick="resetGame()">üîÑ Nouvelle Partie</button>
            <button class="danger" onclick="resetBrain()">üóëÔ∏è Reset M√©moire</button>

            <hr style="border-color: #34495e;">
            <strong>Carte d'apprentissage :</strong>
            <div id="piece-selector" style="display:flex; gap:2px; margin:5px 0; flex-wrap: wrap;"></div>
            <div class="weight-viz" id="weight-viz"></div>
        </div>

        <div class="panel" style="width: 450px;">
            <strong>üå≤ Arbre d'Analyse (Top Coups √âvalu√©s)</strong>
            <div id="tree-container">
                <div style="color: #95a5a6;">En attente du prochain coup de l'IA...</div>
            </div>
        </div>
    </div>

    <script>
        var board = null;
        var game = new Chess();
        const PIECE_TYPES = ['p', 'n', 'b', 'r', 'q', 'k'];
        const PIECE_SYMBOLS = { p: '‚ôü', n: '‚ôû', b: '‚ôù', r: '‚ôú', q: '‚ôõ', k: '‚ôö' };
        let selectedPiece = 'p';
        let searchDepth = 3;
        let selectedSquare = null;

        let aiMemory = JSON.parse(localStorage.getItem('chessAI_memory_v2')) || {
            gamesPlayed: 0,
            wins: 0,
            losses: 0,
            draws: 0,
            weights: {}
        };

        if (Object.keys(aiMemory.weights).length === 0) {
            PIECE_TYPES.forEach(t => aiMemory.weights[t] = new Array(64).fill(0));
            // Initialisation avec bonus de centre pour les pions
            [27, 28, 35, 36].forEach(idx => aiMemory.weights['p'][idx] = 15);
        }

        // Tables de position standard (bonus pour bonnes positions)
        const pieceSquareTables = {
            p: [ // Pions (encourager l'avanc√©e)
                 0,  0,  0,  0,  0,  0,  0,  0,
                50, 50, 50, 50, 50, 50, 50, 50,
                10, 10, 20, 30, 30, 20, 10, 10,
                 5,  5, 10, 25, 25, 10,  5,  5,
                 0,  0,  0, 20, 20,  0,  0,  0,
                 5, -5,-10,  0,  0,-10, -5,  5,
                 5, 10, 10,-20,-20, 10, 10,  5,
                 0,  0,  0,  0,  0,  0,  0,  0
            ],
            n: [ // Cavaliers (centre et contr√¥le)
                -50,-40,-30,-30,-30,-30,-40,-50,
                -40,-20,  0,  0,  0,  0,-20,-40,
                -30,  0, 10, 15, 15, 10,  0,-30,
                -30,  5, 15, 20, 20, 15,  5,-30,
                -30,  0, 15, 20, 20, 15,  0,-30,
                -30,  5, 10, 15, 15, 10,  5,-30,
                -40,-20,  0,  5,  5,  0,-20,-40,
                -50,-40,-30,-30,-30,-30,-40,-50
            ],
            b: [ // Fous (diagonales longues)
                -20,-10,-10,-10,-10,-10,-10,-20,
                -10,  0,  0,  0,  0,  0,  0,-10,
                -10,  0,  5, 10, 10,  5,  0,-10,
                -10,  5,  5, 10, 10,  5,  5,-10,
                -10,  0, 10, 10, 10, 10,  0,-10,
                -10, 10, 10, 10, 10, 10, 10,-10,
                -10,  5,  0,  0,  0,  0,  5,-10,
                -20,-10,-10,-10,-10,-10,-10,-20
            ],
            r: [ // Tours (colonnes ouvertes)
                 0,  0,  0,  0,  0,  0,  0,  0,
                 5, 10, 10, 10, 10, 10, 10,  5,
                -5,  0,  0,  0,  0,  0,  0, -5,
                -5,  0,  0,  0,  0,  0,  0, -5,
                -5,  0,  0,  0,  0,  0,  0, -5,
                -5,  0,  0,  0,  0,  0,  0, -5,
                -5,  0,  0,  0,  0,  0,  0, -5,
                 0,  0,  0,  5,  5,  0,  0,  0
            ],
            q: [ // Reine (centre en milieu de jeu)
                -20,-10,-10, -5, -5,-10,-10,-20,
                -10,  0,  0,  0,  0,  0,  0,-10,
                -10,  0,  5,  5,  5,  5,  0,-10,
                 -5,  0,  5,  5,  5,  5,  0, -5,
                  0,  0,  5,  5,  5,  5,  0, -5,
                -10,  5,  5,  5,  5,  5,  0,-10,
                -10,  0,  5,  0,  0,  0,  0,-10,
                -20,-10,-10, -5, -5,-10,-10,-20
            ],
            k: [ // Roi (s√©curit√© en d√©but)
                -30,-40,-40,-50,-50,-40,-40,-30,
                -30,-40,-40,-50,-50,-40,-40,-30,
                -30,-40,-40,-50,-50,-40,-40,-30,
                -30,-40,-40,-50,-50,-40,-40,-30,
                -20,-30,-30,-40,-40,-30,-30,-20,
                -10,-20,-20,-20,-20,-20,-20,-10,
                 20, 20,  0,  0,  0,  0, 20, 20,
                 20, 30, 10,  0,  0, 10, 30, 20
            ]
        };

        function customPieceTheme(piece) {
            return `https://assets-themes.chess.com/image/ejgfv/150/${piece.toLowerCase()}.png`;
        }

        function isMobile() {
            return /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);
        }

        function setDepth(depth) {
            searchDepth = depth;
            document.getElementById('current-depth').textContent = depth;
            document.querySelectorAll('.depth-btn').forEach(btn => btn.classList.remove('active'));
            event.target.classList.add('active');
        }

        // --- √âVALUATION AM√âLIOR√âE ---
        function evaluateBoard(g) {
            if (g.in_checkmate()) {
                return g.turn() === 'b' ? -50000 : 50000; // √âchec et mat
            }
            if (g.in_draw() || g.in_stalemate() || g.in_threefold_repetition()) {
                return 0;
            }

            let total = 0;
            const values = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 20000 };

            g.board().forEach((row, i) => {
                row.forEach((p, j) => {
                    if (p) {
                        const idx = i * 8 + j;
                        let pieceValue = values[p.type];

                        // Tables de position standard
                        let posBonus = pieceSquareTables[p.type][idx];

                        // Poids appris
                        let learnedWeight = aiMemory.weights[p.type][idx] || 0;

                        // Combinaison: 70% standard, 30% appris
                        let totalValue = pieceValue + (posBonus * 0.7) + (learnedWeight * 0.3);

                        total += (p.color === 'b' ? totalValue : -totalValue);
                    }
                });
            });

            // Bonus pour mobilit√© (nombre de coups possibles)
            const currentTurn = g.turn();
            const mobility = g.moves().length;
            total += currentTurn === 'b' ? mobility * 5 : -mobility * 5;

            return total;
        }

        // --- TRI DES COUPS (Move Ordering pour Alpha-Beta plus efficace) ---
        function orderMoves(g, moves) {
            return moves.map(m => {
                let score = 0;
                const move = g.move(m);

                // Prioriser les captures
                if (move.captured) {
                    const values = { p: 100, n: 320, b: 330, r: 500, q: 900 };
                    score += (values[move.captured] || 0) * 10;
                }

                // Prioriser les √©checs
                if (g.in_check()) score += 50;

                // Prioriser les promotions
                if (move.promotion) score += 900;

                g.undo();
                return { move: m, priority: score };
            })
            .sort((a, b) => b.priority - a.priority)
            .map(item => item.move);
        }

        // --- MINIMAX AVEC ALPHA-BETA ET TRACAGE D'ARBRE ---
        let nodesEvaluated = 0;

        function minimax(g, depth, alpha, beta, isMax, treeElement, isRoot = false) {
            nodesEvaluated++;

            if (depth === 0 || g.game_over()) {
                return evaluateBoard(g);
            }

            let moves = g.moves();
            moves = orderMoves(g, moves); // Tri pour meilleure efficacit√©

            // Limiter l'affichage pour la lisibilit√©
            const displayLimit = isRoot ? 10 : (depth >= 2 ? 5 : 3);
            let bestEval = isMax ? -Infinity : Infinity;

            for (let i = 0; i < moves.length; i++) {
                const m = moves[i];
                let node = null;

                if (i < displayLimit && treeElement) {
                    const indent = '  '.repeat(4 - depth);
                    node = $('<div class="tree-node"></div>')
                        .html(`${indent}${depth === searchDepth ? 'üî∏' : '‚îî‚îÄ'} ${m} <span class="node-depth">[D${depth}]</span>`);
                    treeElement.append(node);
                }

                g.move(m);
                let eval = minimax(g, depth - 1, alpha, beta, !isMax, node, false);
                g.undo();

                if (node) {
                    const scoreClass = eval > 500 ? 'node-best' : eval < -500 ? 'node-bad' : 'node-good';
                    node.append(` <span class="${scoreClass}">[${eval.toFixed(0)}]</span>`);
                }

                if (isMax) {
                    if (eval > bestEval) bestEval = eval;
                    alpha = Math.max(alpha, eval);
                } else {
                    if (eval < bestEval) bestEval = eval;
                    beta = Math.min(beta, eval);
                }

                // √âlagage Alpha-Beta
                if (beta <= alpha) {
                    if (treeElement && i < displayLimit) {
                        treeElement.append($('<div class="tree-node" style="color:#e74c3c;">').text('  ‚úÇÔ∏è √âlagage (autres coups ignor√©s)'));
                    }
                    break;
                }
            }
            return bestEval;
        }

        function makeBestMove() {
            let moves = game.moves();
            if (game.game_over()) return handleGameOver();

            const $tree = $('#tree-container').empty();
            const $status = $('#status');
            $status.html('<span class="thinking">‚è≥ IA analyse...</span>');

            $tree.append(`<div><strong>üîç Analyse Profondeur ${searchDepth}</strong></div><hr style="border-color:#444;">`);

            setTimeout(() => {
                nodesEvaluated = 0;
                const startTime = Date.now();

                let moveEvaluations = [];
                moves = orderMoves(game, moves); // Tri initial

                for (let m of moves) {
                    let moveNode = $('<div style="margin: 10px 0; padding: 8px; background: #2c3e50; border-left: 3px solid #3498db;"></div>')
                        .html(`<strong style="color:#2ecc71;">Coup: ${m}</strong>`);

                    game.move(m);
                    let val = minimax(game, searchDepth - 1, -Infinity, Infinity, false, moveNode);
                    game.undo();

                    moveEvaluations.push({ move: m, val: val, element: moveNode });
                }

                moveEvaluations.sort((a, b) => b.val - a.val);

                // Affichage des 8 meilleurs coups
                $tree.append('<div style="margin: 10px 0;"><strong>Top Coups √âvalu√©s:</strong></div>');
                moveEvaluations.slice(0, 8).forEach((e, idx) => {
                    e.element.prepend(`<span style="color:#f1c40f;">#${idx + 1}</span> `);
                    $tree.append(e.element);
                });

                const timeElapsed = Date.now() - startTime;
                $tree.append(`<hr style="border-color:#444;"><div style="color:#95a5a6; font-size:11px;">
                    ‚ö° ${nodesEvaluated} positions √©valu√©es en ${timeElapsed}ms<br>
                    üéØ Meilleur score: ${moveEvaluations[0].val.toFixed(0)}
                </div>`);

                // Jouer le meilleur coup
                let chosenMove = moveEvaluations[0].move;
                game.move(chosenMove);
                board.position(game.fen());
                updateStatus();

                if (game.game_over()) handleGameOver();
            }, 100);
        }

        // --- APPRENTISSAGE AM√âLIOR√â ---
        function handleGameOver() {
            let result = 0;
            let message = "";

            if (game.in_checkmate()) {
                if (game.turn() === 'w') {
                    result = 1; // IA gagne
                    message = "üéâ L'IA gagne par √©chec et mat !";
                    aiMemory.wins++;
                } else {
                    result = -1; // IA perd
                    message = "üëè Vous avez gagn√© par √©chec et mat !";
                    aiMemory.losses++;
                }
            } else if (game.in_draw() || game.in_stalemate()) {
                result = 0;
                message = "ü§ù Match nul";
                aiMemory.draws++;
            }

            // Apprentissage: ajuster les poids selon le r√©sultat
            const learningRate = result === 1 ? 20 : result === -1 ? -25 : 0;

            game.board().forEach((row, i) => {
                row.forEach((p, j) => {
                    if (p && p.color === 'b') {
                        const idx = i * 8 + j;
                        aiMemory.weights[p.type][idx] += learningRate;

                        // Limiter les poids pour √©viter l'explosion
                        aiMemory.weights[p.type][idx] = Math.max(-500, Math.min(500, aiMemory.weights[p.type][idx]));
                    }
                });
            });

            aiMemory.gamesPlayed++;
            localStorage.setItem('chessAI_memory_v2', JSON.stringify(aiMemory));
            updateStatsUI();
            updateWeightVisualization();

            alert(message);
        }

        function updateStatus() {
            const turn = game.turn() === 'w' ? "ü§µ Votre tour (Blanc)" : "ü§ñ Tour de l'IA (Noir)";
            $('#status').html(turn);

            if (game.in_check()) {
                $('#status').append(' <span style="color:#e74c3c;">‚ôî √âCHEC!</span>');
            }
        }

        function updateStatsUI() {
            $('#game-count').text(aiMemory.gamesPlayed);
            $('#win-count').text(aiMemory.wins);
            $('#loss-count').text(aiMemory.losses);

            const winRate = aiMemory.gamesPlayed > 0
                ? ((aiMemory.wins / aiMemory.gamesPlayed) * 100).toFixed(1)
                : 0;
            $('#win-rate').text(winRate + '%');
        }

        function updateWeightVisualization() {
            const weights = aiMemory.weights[selectedPiece];
            const maxW = Math.max(...weights.map(Math.abs), 1);
            let html = '';
            weights.forEach(w => {
                let intensity = Math.min(255, Math.abs(w / maxW * 255));
                let color = w >= 0 ? `rgb(46, ${255-intensity}, 71)` : `rgb(${255-intensity}, 52, 60)`;
                const val = Math.abs(w) > 5 ? Math.round(w) : '';
                html += `<div class="weight-cell" style="background:${color}; color:white; font-weight:bold;">${val}</div>`;
            });
            $('#weight-viz').html(html);
        }

        function initPieceSelector() {
            let html = '';
            PIECE_TYPES.forEach(t => {
                const active = t === selectedPiece ? 'active' : '';
                html += `<button class="depth-btn ${active}" style="width:auto; font-size:14px;" onclick="selectedPiece='${t}';initPieceSelector();updateWeightVisualization();">${PIECE_SYMBOLS[t]} ${t.toUpperCase()}</button>`;
            });
            $('#piece-selector').html(html);
        }

        function resetGame() {
            game.reset();
            board.start();
            updateStatus();
            $('#tree-container').html('<div style="color: #95a5a6;">En attente du prochain coup de l\'IA...</div>');
            removeHighlight();
        }

        function resetBrain() {
            if (confirm('Voulez-vous vraiment effacer toute la m√©moire de l\'IA ?')) {
                localStorage.removeItem('chessAI_memory_v2');
                location.reload();
            }
        }

        // Efface toute surbrillance
        function removeHighlight() {
            $('.square-55d63').removeClass('highlight-move highlight-selected');
        }

        // Surligne les coups possibles pour une pi√®ce
        function highlightPossibleMoves(square) {
            removeHighlight();
            const moves = game.moves({ square: square, verbose: true });
            moves.forEach(move => {
                $(`.square-${move.to}`).addClass('highlight-move');
            });
            $(`.square-${square}`).addClass('highlight-selected');
        }

        // Initialisation du plateau
        board = Chessboard('board', {
            draggable: !isMobile(),
            position: 'start',
            pieceTheme: customPieceTheme,
            onDragStart: (source, piece) => {
                if (game.game_over()) return false;
                if (piece.search(/^b/) !== -1) return false;
                highlightPossibleMoves(source);
            },
            onDrop: (s, t) => {
                removeHighlight();
                let move = game.move({ from: s, to: t, promotion: 'q' });
                if (move === null) return 'snapback';
                updateStatus();
                window.setTimeout(makeBestMove, 250);
            },
            onSnapEnd: () => board.position(game.fen()),
            onClick: (square) => {
                if (isMobile() && !game.game_over()) {
                    const piece = game.get(square);
                    if (piece && piece.color === 'w') {
                        selectedSquare = square;
                        highlightPossibleMoves(square);
                    } else if (selectedSquare) {
                        const move = game.move({ from: selectedSquare, to: square, promotion: 'q' });
                        if (move === null) {
                            removeHighlight();
                            selectedSquare = null;
                            return;
                        }
                        removeHighlight();
                        selectedSquare = null;
                        updateStatus();
                        window.setTimeout(makeBestMove, 250);
                    }
                }
            }
        });

        if (isMobile()) {
            $('#mobile-help').show();
        }

        initPieceSelector();
        updateWeightVisualization();
        updateStatsUI();
        updateStatus();
    </script>
</body>
</html>
